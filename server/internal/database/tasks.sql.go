// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tasks.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTask = `-- name: CreateTask :exec
INSERT INTO tasks (id, workspace_id, project_id, assignee_id, name, description, position, due_date, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type CreateTaskParams struct {
	ID          uuid.UUID
	WorkspaceID uuid.UUID
	ProjectID   uuid.UUID
	AssigneeID  uuid.NullUUID
	Name        string
	Description sql.NullString
	Position    int32
	DueDate     sql.NullTime
	Status      sql.NullString
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.WorkspaceID,
		arg.ProjectID,
		arg.AssigneeID,
		arg.Name,
		arg.Description,
		arg.Position,
		arg.DueDate,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1 AND workspace_id = $2 AND project_id = $3
`

type DeleteTaskParams struct {
	ID          uuid.UUID
	WorkspaceID uuid.UUID
	ProjectID   uuid.UUID
}

func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.ExecContext(ctx, deleteTask, arg.ID, arg.WorkspaceID, arg.ProjectID)
	return err
}

const getAllTasks = `-- name: GetAllTasks :many
SELECT id, workspace_id, project_id, assignee_id, name, description, position, due_date, status, created_at, updated_at FROM tasks
WHERE 
    workspace_id = $1
    AND project_id = $2
ORDER BY created_at DESC
`

type GetAllTasksParams struct {
	WorkspaceID uuid.UUID
	ProjectID   uuid.UUID
}

func (q *Queries) GetAllTasks(ctx context.Context, arg GetAllTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getAllTasks, arg.WorkspaceID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProjectID,
			&i.AssigneeID,
			&i.Name,
			&i.Description,
			&i.Position,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredTasks = `-- name: GetFilteredTasks :many
SELECT id, workspace_id, project_id, assignee_id, name, description, position, due_date, status, created_at, updated_at FROM tasks
WHERE 
    workspace_id = $1
    AND project_id = $2
    AND ($3::uuid IS NULL OR assignee_id = $3::uuid)
    AND ($4 = '' OR status = $4)
    AND ($5::timestamp IS NULL OR due_date = $5::timestamp)  
ORDER BY created_at DESC
`

type GetFilteredTasksParams struct {
	WorkspaceID uuid.UUID
	ProjectID   uuid.UUID
	Column3     uuid.UUID
	Column4     interface{}
	Column5     time.Time
}

func (q *Queries) GetFilteredTasks(ctx context.Context, arg GetFilteredTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredTasks,
		arg.WorkspaceID,
		arg.ProjectID,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProjectID,
			&i.AssigneeID,
			&i.Name,
			&i.Description,
			&i.Position,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskMembers = `-- name: GetTaskMembers :many
SELECT m.id, m.role, u.id AS user_id, u.username AS user_username, u.image AS user_image
FROM members m
LEFT JOIN users u ON m.user_id = u.id
WHERE m.workspace_id = $1
ORDER BY m.created_at ASC
`

type GetTaskMembersRow struct {
	ID           uuid.UUID
	Role         string
	UserID       uuid.NullUUID
	UserUsername sql.NullString
	UserImage    sql.NullString
}

func (q *Queries) GetTaskMembers(ctx context.Context, workspaceID uuid.UUID) ([]GetTaskMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskMembers, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskMembersRow
	for rows.Next() {
		var i GetTaskMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.UserID,
			&i.UserUsername,
			&i.UserImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskProject = `-- name: GetTaskProject :one
SELECT name, image_url FROM projects WHERE workspace_id = $1 AND id = $2
`

type GetTaskProjectParams struct {
	WorkspaceID uuid.UUID
	ID          uuid.UUID
}

type GetTaskProjectRow struct {
	Name     string
	ImageUrl sql.NullString
}

func (q *Queries) GetTaskProject(ctx context.Context, arg GetTaskProjectParams) (GetTaskProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskProject, arg.WorkspaceID, arg.ID)
	var i GetTaskProjectRow
	err := row.Scan(&i.Name, &i.ImageUrl)
	return i, err
}

const getTaskProjects = `-- name: GetTaskProjects :many
SELECT id, name, image_url FROM projects WHERE workspace_id = $1 ORDER BY created_at DESC
`

type GetTaskProjectsRow struct {
	ID       uuid.UUID
	Name     string
	ImageUrl sql.NullString
}

func (q *Queries) GetTaskProjects(ctx context.Context, workspaceID uuid.UUID) ([]GetTaskProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskProjects, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskProjectsRow
	for rows.Next() {
		var i GetTaskProjectsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ImageUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskWithHighestPosition = `-- name: GetTaskWithHighestPosition :one
SELECT position FROM tasks WHERE workspace_id = $1 AND project_id = $2 ORDER BY position DESC LIMIT 1
`

type GetTaskWithHighestPositionParams struct {
	WorkspaceID uuid.UUID
	ProjectID   uuid.UUID
}

func (q *Queries) GetTaskWithHighestPosition(ctx context.Context, arg GetTaskWithHighestPositionParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getTaskWithHighestPosition, arg.WorkspaceID, arg.ProjectID)
	var position int32
	err := row.Scan(&position)
	return position, err
}

const getUserById = `-- name: GetUserById :one
SELECT username, image FROM users WHERE id = $1
`

type GetUserByIdRow struct {
	Username string
	Image    sql.NullString
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(&i.Username, &i.Image)
	return i, err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET 
    name = $1,
    description = $2,
    status = $3,
    due_date = $4,
    position = $5,
    assignee_id = $6,
    project_id = $7,
    updated_at = NOW()
WHERE id = $8 AND workspace_id = $9 AND project_id = $10
`

type UpdateTaskParams struct {
	Name        string
	Description sql.NullString
	Status      sql.NullString
	DueDate     sql.NullTime
	Position    int32
	AssigneeID  uuid.NullUUID
	ProjectID   uuid.UUID
	ID          uuid.UUID
	WorkspaceID uuid.UUID
	ProjectID_2 uuid.UUID
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.DueDate,
		arg.Position,
		arg.AssigneeID,
		arg.ProjectID,
		arg.ID,
		arg.WorkspaceID,
		arg.ProjectID_2,
	)
	return err
}
